package cluster

import (
	"fmt"
	"sort"
	"strconv"
	"strings"
)

// marshalSlotIds serializes slot ids
// For example, 1, 2, 3, 5, 7, 8 -> 1-3, 5, 7-8
func marshalSlotIds(slots []*Slot) [][]byte {
	sort.Slice(slots, func(i, j int) bool {
		return slots[i].ID < slots[j].ID
	})
	// find continuous scopes
	var scopes [][]uint32
	buf := make([]uint32, 2)
	var scope []uint32
	for i, slot := range slots {
		if len(scope) == 0 { // outside scope
			if i+1 < len(slots) &&
				slots[i+1].ID == slot.ID+1 { // if continuous, then start one
				scope = buf
				scope[0] = slot.ID
			} else { // discrete number
				scopes = append(scopes, []uint32{slot.ID})
			}
		} else {                                                 // within a scope
			if i == len(slots)-1 || slots[i+1].ID != slot.ID+1 { // reach end or not continuous, stop current scope
				scope[1] = slot.ID
				scopes = append(scopes, []uint32{scope[0], scope[1]})
				scope = nil
			}
		}

	}

	// marshal scopes
	result := make([][]byte, 0, len(scopes))
	for _, scope := range scopes {
		if len(scope) == 1 {
			s := strconv.Itoa(int(scope[0]))
			result = append(result, []byte(s))
		} else { // assert len(scope) == 2
			beg := strconv.Itoa(int(scope[0]))
			end := strconv.Itoa(int(scope[1]))
			result = append(result, []byte(beg+"-"+end))
		}
	}
	return result
}

// unmarshalSlotIds deserializes lines generated by marshalSlotIds
func unmarshalSlotIds(args [][]byte) ([]uint32, error) {
	var result []uint32
	for i, bin := range args {
		line := string(bin)
		if pivot := strings.IndexByte(line, '-'); pivot > 0 {
			// line is a scope
			beg, err := strconv.Atoi(line[:pivot])
			if err != nil {
				return nil, fmt.Errorf("illegal at slot line %d", i+1)
			}
			end, err := strconv.Atoi(line[pivot+1:])
			if err != nil {
				return nil, fmt.Errorf("illegal at slot line %d", i+1)
			}
			for j := beg; j <= end; j++ {
				result = append(result, uint32(j))
			}
		} else {
			// line is a number
			v, err := strconv.Atoi(line)
			if err != nil {
				return nil, fmt.Errorf("illegal at slot line %d", i)
			}
			result = append(result, uint32(v))
		}
	}
	return result, nil
}

func marshalMigratingSlots(slots []*Slot) [][]byte {
	/* migrating slot line structure: slotId-newNodeId */
	result := make([][]byte, 0)
	for _, slot := range slots {
		if slot.IsMigrating() {
			line := []byte(strconv.Itoa(int(slot.ID)) + "-" + slot.OldNodeID)
			result = append(result, line)
		}
	}
	return result
}

func unmarshalMigratingSlots(args [][]byte) (map[uint32]*Slot, error) {
	result := make(map[uint32]*Slot)
	for i, bin := range args {
		line := string(bin)
		if pivot := strings.IndexByte(line, '-'); pivot > 0 {
			// line is a scope
			slotId0, err := strconv.Atoi(line[:pivot])
			if err != nil {
				return nil, fmt.Errorf("illegal at migrating slot line %d", i+1)
			}
			slotId := uint32(slotId0)
			oldNodeId := line[pivot+1:]
			result[slotId] = &Slot{
				ID:        slotId,
				OldNodeID: oldNodeId,
			}
		}
	}
	return result, nil
}

func marshalTopology(nodes map[string]*Node) [][]byte {
	var args [][]byte
	for _, node := range nodes {
		/* node structure:
		* node id
		* node address
		* number of line describing slots in node AND number of migrating slots
		* line describing slots in node which has two formats:
			* slot id
			* first slot id - last slot id (inclusive)
		* lines describing migrating slot: slotId-newNodeId
		*/
		args = append(args, []byte(node.ID))
		args = append(args, []byte(node.Addr))
		slotLines := marshalSlotIds(node.Slots)
		migratingSlotLines := marshalMigratingSlots(node.Slots)
		line3 := strconv.Itoa(len(slotLines)) + "-" + strconv.Itoa(len(migratingSlotLines))
		args = append(args, []byte(line3))
		args = append(args, slotLines...)
		args = append(args, migratingSlotLines...)
	}
	return args
}

func unmarshalTopology(args [][]byte) (map[string]*Node, error) {
	nodeMap := make(map[string]*Node)
	i := 0
	for i+2 < len(args) { // a node has at least 3 lines
		node := new(Node)
		node.ID = string(args[i])
		node.Addr = string(args[i+1])
		line3 := string(args[i+2])
		pivot := strings.IndexByte(line3, '-')
		if pivot < 0 {
			return nil, fmt.Errorf("illegal line3 at line %d", i+2)
		}
		slotLineCount, err := strconv.Atoi(line3[:pivot])
		if err != nil {
			return nil, fmt.Errorf("illegal slotLineCount at line %d", i+2)
		}
		migratingSlotLineCount, err := strconv.Atoi(line3[pivot+1:])
		if err != nil {
			return nil, fmt.Errorf("illegal migratingSlotLineCount at line %d", i+2)
		}
		migratingSlots, err := unmarshalMigratingSlots(args[i+3+slotLineCount : i+3+slotLineCount+migratingSlotLineCount])
		if err != nil {
			return nil, fmt.Errorf("parse migratingSlots of node %s error: %v", node.ID, err)
		}
		if slotLineCount > 0 {
			slotIds, err := unmarshalSlotIds(args[i+3 : i+3+slotLineCount])
			if err != nil {
				return nil, fmt.Errorf("parse slots of node %s error: %v", node.ID, err)
			}
			for _, slotId := range slotIds {
				slot := &Slot{
					ID:     slotId,
					NodeID: node.ID,
					Flags:  0,
				}
				migrating := migratingSlots[slotId]
				if migrating != nil {
					slot.OldNodeID = migrating.OldNodeID
					slot.Flags |= slotFlagMigrating
				}
				node.Slots = append(node.Slots, slot)
			}
		}
		nodeMap[node.ID] = node
		i += 3 + slotLineCount + migratingSlotLineCount
	}
	return nodeMap, nil
}
